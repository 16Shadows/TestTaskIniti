# Описание
Тестовое задание для ООО "ИНИТИ".
Симуляция перекрёстка, алгоритм работы светофора на перекрёстке, визуализация симуляции.
## Технологии
* .Net 7 (C#)
* Windows Presentation Framework (для визуализации)
## Структура проекта (кратко)
* Simulation - компоненты симуляции перекрёстка.
* Algorithm - компоненты FSM (Finite State Machine) конфигураций светофоров с одним управляющим светофором для общего случая.
* Visualization - WPF-приложение для визуализации задачи, симуляция конкретного перекрёстка из задачи, набор состояний FSM для конкретного перекрёстка из задачи ([CrossroadsViewModel](https://github.com/16Shadows/TestTaskIniti/blob/developer/Visualization/ViewModels/CrossroadsViewModel.cs)).
## Постановка задачи
В задаче дан перекрёсток (см. рисунок). В каждый светофор встроена камера, которая фиксирует количество желающих пересечь перекрёсток автомобилей/пешеходов, для которых этот светофор установлен.
Автомобили могут проехать прямо или повернуть направо. Автомобили/пешеходы пересекают переход по одному из каждой очереди.

Светофоры имеют уникальные ID и могут отправлять другому светофору по ID произвольное сообщение сразу же или после заданной светофором задержки.
Доставленое сообщение помещается в очередь сообщений светофора. Светофоры обрабатывают сообщения параллельно, в порядке из добавления в очередь.
Также светофор может синхронно получить состояние любого другого светофора.
![image](https://github.com/user-attachments/assets/f3523be7-9922-4600-8305-253bf0541783)

Необходимо реализовать алгоритм управления перекрёстком, который будет максимизировать пропускную способность перекрёстка.
# Решение задачи
В рамках решения задачи реализуем симуляцию перекрёстка и алгоритм работы его работы. Также реализуем визуализацию, чтобы было наглядно видно, что происходит на перекрёстке.
## Предположения
В постановке задачи не указан ряд условий, поэтому выдвинем следующий предположения для построения симуляции и разработки алгоритма управления:
* И у автомобилей, и у пешеходов пересечение перекрёстка занимает фиксированное время.
* Автомобили мгновенно приходят в движение и мгновенно тормозят, поэтому жёлтый свет светофора не имеет значения и исключен из симуляции.
* На светофорах могут быть установлены разные алгоритмы управления.
* Машины и пешеходы игнорируют другие машины и других пешеходов, принимая решение о движении только на основе сигнала светофора. Как следствие, если на пересекающихся дорогах/переходах горит зелёный свет и в их очередях ожидают машины/пешеходы, то произойдёт авария. В таком случае симуляция будет завершена.
* Пропускная способность определяется как количество машин/пешеходов, пересёкших перекрёсток за некоторый промежуток времени.
## Симуляция
Реализуемая симуляция будет многопоточной.
Для упрощения разработки различных сущностей сделаем базовый класс сущности симуляции ([SimulationEntityBase](https://github.com/16Shadows/TestTaskIniti/blob/developer/Simulation/Core/SimulationEntityBase.cs)), который будет отвечать за запуск и остановку потока симуляции сущности.

![image](https://github.com/user-attachments/assets/ea9ecb62-169f-44f3-a846-666987898779)
### Очереди
Сразу отметим, что в контексте описанных условий нет реальной разницы между пешеходами и автомобилями. Поэтому будем рассматривать и пешеходов, и автомобили как абстрактные сущности, пересекающие перекрёсток. Реализуем для них единообразный класс очереди, который будет через некоторый случайный промежуток времени добавлять 1 сущность в очередь.

![image](https://github.com/user-attachments/assets/54ce7a35-1364-4a4e-ac9e-efa98bc7c3b7)

### Камеры
Для симуляции фиксации камерой очереди (и возможных задержек распознавания), камера будет в своём потоке симуляции поллить размер соответствующей очереди раз в некоторый промежуток времени.

![image](https://github.com/user-attachments/assets/29510d53-41e1-42e8-8896-18e63630261c)

### Светофоры
Для реализации комплексной логики светофора декомпозируем его на несколько интерфейсов:
* ITrafficLight - интерфейс для взаимодействия внешних сущностей (других светофоров или перекрёстка) с этим светофором.
* ITrafficLightBrain - интерфейс для управления этим светофором изнутри.
* ITrafficLightChannel - интерфейс для компонента отправки сообщений другим светофорам.
* ITrafficLightBrain - компонент для компонента, который будет управлять этим светофором, принимая решения о смене состояния о отправке сообщений.
Реализуем эти компоненты двумя классами:
* TrafficLight - сущность для симуляции светофора.
* TrafficLightMediator - медиатор, который обеспечивает доставку сообщений между светофорами по ID.

![image](https://github.com/user-attachments/assets/341d17f5-adc7-4c60-8ca1-5a07836b3f75)

### Перекрёсток
Для реализации логики прохождения перекрёстка представим перекрёсток в виде набора путей.
Путь может иметь желающих пройти/проехать по нему и разрешение светофора на это (т.е. путь "желает быть пройденным", только если в очереди кто-то есть и светофор разрешает движение по пути), а также может иметь потенциальную аварию на пути.
Вся симуляция прохождения перекрёстка реализована в одном потоке.

![image](https://github.com/user-attachments/assets/d580ebc9-e1d0-4f3e-a20a-435c34e60e48)

## Алгоритм работы светофоров
Перейдём теперь к рассмотрению самого алгоритма работы светофора.

Сразу можно отметить, что если на каждом светофоре поставить идентичный алгоритм управления самим светофором на основе состояния других светофоров, синхронизировать такую систему будет крайне сложно.
Гораздо надёжнее и проще будет реализовать один "главный" светофор, который будет принимать решения о наиболее выгодной с точки зрения пропускной способности конфигурации светофоров и управлять остальными светофорами.
Остальные светофоры в таком случае будут "подчинёнными" и будут лишь сообщать "главному" светофору размер своей очереди, а также изменять своё состояние по команде от "главного" светофора.

Весь перекрёсток имеет конечное число конфигураций (12 светофоров с 2 состояниями - 2^12 = 4096). При этом можно заметить, что огромное число конфигураций не имеет смысла в рассматриваемых условиях, так как приведёт к аварии.
На рисунке ниже изображены все пути через перекрёсток (переходы объединены в одну стрелку, т.к. для переходов через одну дорогу на противоположные стороны пересечения одинаковые; их можно рассматривать как один переход; это уменьшает число конфигураций до 2^8=256).

![image](https://github.com/user-attachments/assets/d4f7dd6c-2aa3-4fd5-b8dd-cd8036ebe514)

Определим конфигурации, которые не будут приводит к аварии (примечание: т.к. предполагается, что водители игнорируют другие машины, поворот направо на дорогу, по которой уже едет другая машина или переходит пешеход, будет считаться аварией):
* 12 конфигураций только с одним "зелёным" светофором.
* 4 конфигурации с "зелёным" светофором на дороге и "зелёным" у противоположного перехода.

  ![image](https://github.com/user-attachments/assets/b0edf566-de50-4a18-8d9f-7f83e07316cf)
* 2 конфигурации с "зелёным" у противонаправленных дорог.

  ![image](https://github.com/user-attachments/assets/8f3f70ec-7b4d-4cfc-a90a-3fb2649c9e69)
* 1 конфигурация с "зелёным" на всех переходах.

  ![image](https://github.com/user-attachments/assets/591d3e4d-ad3f-4159-a39b-e1e5d10abc7d)

Всего получаем 19 конфигураций. При этом первые 12 конфигураций являются составной частью одной из последний 7, поэтому их можно исключить. Таким образом получаем 7 возможных конфигураций светофоров на перекрёстке.
Следовательно, во время работы перекрёстка будет выбираться одна из 7 конфигураций.

Наибольшей пропускной способностью в конкретный момент времени из этих 7 конфигураций будет обладать та, в которой "зелёные" светофоры будут иметь наибольшее количество непустых очередей (при этом размер очереди значения не имеет, исходя из определения пропускной способности).
Если мы найдём несколько конфигураций с одинаковой пропускной способностью в конкретный момент времени, то будем выбирать ту, в которой суммарный размер очередей наибольший, чтобы пытаться минимизировать размер очередей.

Данный алгоритм, по своей сути, является FSM (Finite State Machine), где переход возможен из любого состояния в любое другое, а целевое состояние выбирается состоянием с наибольшей "оценкой" (количество непустых очередей, затем наибольший суммарный размер очередей).
Этот алгоритм реализован в проекте Algorithm для произвольного набора состояний.
## Визуализация
В проекте Visualization реализована визуализация перекрёстка из задачи.
Также в CrossroadsViewModel реализовано конструирование симуляции перекрёстка из задачи и создание состояний FSM для перекрёстка из задачи, рассмотренных в предыдущем пункте.

[Видео-демонстрация](https://github.com/user-attachments/assets/10a47879-1d66-4d81-8a19-620e467e33f7)
